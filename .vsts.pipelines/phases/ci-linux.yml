parameters:
  matrix: null
  name: ci
  queueDemands: docker
  queueName: DotNetCore-Linux
  buildTarball: false
  buildTarballOffline: false
  imageName: null

phases:
- phase: ${{ parameters.name }}
  variables:
    # Prefix to distinguish artifacts from different legs.
    artifactName: ${{ format('$(type)_{0}', parameters.name) }}
    buildLoggingOptions: ''
    buildConfiguration: Release
    buildTarball: false
    buildTarballOffline: false
    # Use ":z" to set selinux flag for sharing in build-owned root dir. https://docs.docker.com/storage/bind-mounts/#configure-the-selinux-label
    docker.agentSrc.map: -v $(Build.SourcesDirectory):/agentSrc:z
    docker.agentSrc.work: -w /agentSrc
    docker.drop.map: -v $(dropDirectory):/drop:z
    docker.logs.map: -v $(dropDirectory)/logs:/logs:z
    docker.root.map: -v $(rootDirectory):/root:z
    docker.run: docker run --rm
    docker.src.map: -v $(rootDirectory)/sb/source-build:/src:z
    docker.src.work: -w /src
    docker.tb.map: -v $(rootDirectory)/sb/tarball:/tb:z
    docker.tb.work: -w /tb
    dropDirectory: $(stagingDirectory)/drop
    imageName: ${{ parameters.imageName }}
    rootDirectory: $(Build.SourcesDirectory)/..
    stagingDirectory: $(rootDirectory)/sb/staging
    tarballName: tarball_$(Build.BuildId)
  queue:
    name: ${{ parameters.queueName }}
    demands: ${{ parameters.queueDemands }}
    timeoutInMinutes: 240
    parallel: 3
    matrix:
      online:
        type: online
      ${{ if eq(parameters.buildTarball, 'true') }}:
        tarball:
          type: tarball
          buildTarball: true
      ${{ if eq(parameters.buildTarballOffline, 'true') }}:
        tarball_offline:
          type: tarball_offline
          buildTarball: true
          buildTarballOffline: true

  steps:
  - template: ../steps/docker-cleanup-linux.yml

  # Create working directory and copy source into it.
  - script: |
      set -x
      $(docker.run) $(docker.root.map) $(docker.agentSrc.map) $(docker.agentSrc.work) $(imageName) bash -c '
        rm -rf /root/sb/
        mkdir -p /root/sb/tarball
        cp -r . /root/sb/source-build'
    displayName: Clean sb directory and copy source from cloned directory

  - template: ../steps/init-submodules-sh.yml
    parameters:
      commandPrefix: $(docker.run) $(docker.src.map) $(docker.src.work) $(imageName)

  # Build source-build.
  - script: |
      $(docker.run) $(docker.src.map) $(docker.src.work) $(imageName) ./build.sh \
        /p:Configuration=$(buildConfiguration) \
        /p:ArchiveDownloadedPackages=$(buildTarball) \
        /p:ContinueOnPrebuiltBaselineError=$(buildTarball) \
        /p:ProdConBlobFeedUrlPrefix=$(prodConBlobFeedUrlPrefix) \
        $(buildLoggingOptions)
    displayName: Build source-build
    timeoutInMinutes: 90


  # Run smoke tests.
  - script: |
      $(docker.run) $(docker.src.map) $(docker.src.work) $(imageName) ./build.sh \
        /t:RunSmokeTest \
        /p:Configuration=$(buildConfiguration) \
        /p:ProdConBlobFeedUrlPrefix=$(prodConBlobFeedUrlPrefix)
    displayName: Run smoke-test

  # Create tarball.
  - script: |
      $(docker.run) $(docker.tb.map) $(docker.src.map) $(docker.src.work) $(imageName) ./build-source-tarball.sh \
        "/tb/$(tarballName)" \
        --skip-build
    displayName: Create tarball
    condition: and(succeeded(), eq(variables['buildTarball'], true))

  # tar the tarball directory into the drop directory.
  - script: |
      $(docker.run) $(docker.tb.map) $(docker.drop.map) $(docker.tb.work) $(imageName) /bin/bash -c '
        mkdir -p /drop/tarball/
        smokeTestPackages="$(tarballName)/prebuilt/smoke-test-packages"
        # smokeTestPackages is a package cache, with redundant data and unnecessary structure. E.g.
        # $smokeTestPackages/name/version/name.version.nupkg <- We want this.
        # $smokeTestPackages/name/version/lib/net46/name.dll <- This is already in the nupkg.
        # This find moves the nupkg files into $smokeTestPackages:
        find "$smokeTestPackages" -iname "*.nupkg" -exec mv {} "$smokeTestPackages" \;
        # This find removes all non-nupkg files, which are not wanted:
        find "$smokeTestPackages" -not -iname "*.nupkg" -delete
        # Make one .tar.gz for build, another for extras necessary to smoke test:
        tar --numeric-owner "--exclude=$smokeTestPackages" -zcf "/drop/tarball/$(tarballName).tar.gz" "$(tarballName)"
        tar --numeric-owner -zcf "/drop/tarball/$(tarballName)-smoke-test-prereqs.tar.gz" "$smokeTestPackages"'
    displayName: Copy tarball to output
    condition: and(succeeded(), eq(variables['buildTarball'], true))

  # Build tarball.
  - script: |
      networkArg=
      if [ "$(buildTarballOffline)" = "true" ]; then
        networkArg="--network='none'"
      fi
      $(docker.run) $(docker.tb.map) $(docker.tb.work) $networkArg $(imageName) "$(tarballName)/build.sh" \
        /p:Configuration=$(buildConfiguration) \
        $(buildLoggingOptions)
    displayName: Build tarball
    timeoutInMinutes: 90
    condition: and(succeeded(), eq(variables['buildTarball'], true))

  # Run smoke tests.
  - script: |
      $(docker.run) $(docker.tb.map) $(docker.tb.work) $(imageName) "$(tarballName)/smoke-test.sh" \
        --minimal \
        --projectOutput \
        --configuration $(buildConfiguration) \
        --prodConBlobFeedUrl ''
    displayName: Run smoke-test in tarball
    condition: and(succeeded(), eq(variables['buildTarball'], true))

  # Copy logs and reports to staging directory.
  - script: |
      set -x
      $(docker.run) $(docker.logs.map) $(docker.src.map) $(docker.src.work) $(imageName) /bin/bash -c "
        mkdir -p /logs/source-build/logs
        find . \( \
          -path './bin/*-report/*' -o \
          -iname '*.binlog' -o \
          -iname '*.log' \) \
          -exec cp {} --parents /logs/source-build/logs \;"
    displayName: Copy source-build logs
    condition: always()
    continueOnError: true
  - script: |
      set -x
      $(docker.run) $(docker.logs.map) $(docker.tb.map) $(docker.tb.work) $(imageName) /bin/bash -c "
        mkdir -p /logs/tarball/logs
        cd \"$(tarballName)\"
        find . \( \
          -path './bin/*-report/*' -o \
          -iname '*.binlog' -o \
          -iname '*.log' \) \
          -exec cp {} --parents /logs/tarball/logs \;"
    displayName: Copy tarball logs
    condition: eq(variables['buildTarball'], true)
    continueOnError: true

  # Copy artifacts to staging - Copy to VSTS owned folder is done outside of docker so copied files
  # have correct ownership so VSTS can clean them up later.
  - task: CopyFiles@2
    condition: always()
    continueOnError: true
    inputs:
      sourceFolder: $(stagingDirectory)
      targetFolder: $(Build.ArtifactStagingDirectory)

  # Publish artifacts.
  - task: PublishBuildArtifacts@1
    displayName: Publish Logs artifact
    condition: always()
    continueOnError: true
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)/drop/logs
      ArtifactName: Logs $(artifactName)
      ArtifactType: Container
  - task: PublishBuildArtifacts@1
    displayName: Publish Tarball artifact
    condition: eq(variables['buildTarball'], true)
    continueOnError: true
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)/drop/tarball
      ArtifactName: Tarball $(artifactName)
      ArtifactType: Container

  # Clean up (very large) working directory. root owner makes it difficult for others to remove.
  - script: $(docker.run) $(docker.root.map) $(imageName) bash -c 'rm -rf /root/sb'
    displayName: Clean sb directory
    condition: always()
    continueOnError: true

  - template: ../steps/docker-cleanup-linux.yml
